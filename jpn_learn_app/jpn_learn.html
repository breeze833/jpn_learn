<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <link rel="manifest" href="./jpn_learn_manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>æ—¥èªå­¸ç¿’åŠ©æ‰‹ (50éŸ³ + å¥å­è§£æ)</title>
    <script>
        if ('serviceWorker' in navigator) {
          // è·Ÿç€è¦½å™¨ã€Œé ç´„ã€äº†ä¸€ä»¶äº‹ï¼šã€Œç­‰ä¸€ä¸‹å…¨éƒ¨è¼‰å…¥å®Œç•¢å¾Œï¼Œè«‹å«æˆ‘ä¸€è²ã€‚ã€
          window.addEventListener('load', () => {
            // çœŸæ­£åŸ·è¡Œè¨»å†Šçš„æ™‚åˆ»ï¼Œå·²ç¶“æ˜¯å¾ˆä¹…ä»¥å¾Œäº†
            navigator.serviceWorker.register('./jpn_learn_sw.js');
            console.log('SW è¨»å†Šå•Ÿå‹•');
          });
        }
    </script>
    <style>
        /* =========================================
           1. å…¨åŸŸè®Šæ•¸èˆ‡é‡ç½®
           ========================================= */
        :root {
            --primary: #2196F3;
            --primary-kana: #ff7eb3;
            --bg: #f5f7fa;
            --header-bg: #ffffff;
            --text-main: #2c3e50;
        }

        * { box-sizing: border-box; }
        
        body {
            font-family: "Microsoft JhengHei", "Helvetica Neue", sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* =========================================
           2. App Shell (Header & Nav)
           ========================================= */
        header.app-header {
            background: var(--header-bg);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
            padding: 10px 20px;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .app-title { font-size: 1.2rem; font-weight: bold; color: #333; display: flex; align-items: center; gap: 8px;}
        
        /* å…¨åŸŸæ§åˆ¶å€ */
        .global-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 0.9rem;
            background: #f0f2f5;
            padding: 5px 15px;
            border-radius: 20px;
        }

        .status-pill {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
            user-select: none;
        }
        .status-pill:hover { background: #e0e0e0; }
        
        /* ç‹€æ…‹ç‡ˆè™Ÿ */
        .status-indicator { 
            width: 10px; height: 10px; border-radius: 50%; 
            background: #ccc; 
            box-shadow: 0 0 2px rgba(0,0,0,0.2);
            display: none; /* é è¨­éš±è— */
        }
        .status-indicator.visible { display: inline-block; }
        
        .status-green { background: #4CAF50; box-shadow: 0 0 6px #4CAF50; }
        .status-orange { background: #ff9800; box-shadow: 0 0 6px #ff9800; }
        
        .status-icon { font-size: 1.1rem; }
        .status-text { font-size: 0.85rem; font-weight: bold; color: #555; }

        .speed-control { display: flex; align-items: center; gap: 5px; margin-left: 10px; border-left: 1px solid #ccc; padding-left: 10px;}
        input[type=range] { width: 80px; cursor: pointer; }

        /* å°èˆªé ç±¤ (Tabs) */
        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 20px;
            border-bottom: 1px solid #eee;
        }

        .tab-btn {
            padding: 10px 20px;
            border: none;
            background: none;
            font-size: 1rem;
            color: #777;
            cursor: pointer;
            position: relative;
            font-weight: bold;
        }

        .tab-btn.active { color: var(--primary); }
        .tab-btn.active::after {
            content: ''; position: absolute; bottom: -1px; left: 0; width: 100%; height: 3px; background: var(--primary);
        }
        
        .tab-btn[data-target="view-kana"].active { color: var(--primary-kana); }
        .tab-btn[data-target="view-kana"].active::after { background: var(--primary-kana); }

        /* =========================================
           3. View Containers
           ========================================= */
        main { flex: 1; padding: 20px; width: 100%; max-width: 1000px; margin: 0 auto; }
        .view-section { display: none; animation: fadeIn 0.3s ease; }
        .view-section.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* =========================================
           4. View A: 50éŸ³
           ========================================= */
        .kana-controls { text-align: center; margin-bottom: 20px; }
        .kana-toggle-btn {
            padding: 6px 16px; border: 2px solid var(--primary-kana); background: white; color: var(--primary-kana);
            border-radius: 20px; cursor: pointer; font-weight: bold; margin: 0 5px; transition: 0.2s;
        }
        .kana-toggle-btn.active { background: var(--primary-kana); color: white; }

        .grid-container {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); 
            gap: 10px; max-width: 600px; margin: 0 auto;
        }
        @media(min-width: 500px) { .grid-container { grid-template-columns: repeat(5, 1fr); } }

        .char-card {
            background: white; border-radius: 10px; aspect-ratio: 1;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05); cursor: pointer; transition: transform 0.2s;
            border: 1px solid transparent;
        }
        .char-card:hover { transform: translateY(-3px); border-color: var(--primary-kana); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .char-main { font-size: 1.8rem; font-weight: bold; color: #333; }
        .char-sub { font-size: 0.8rem; color: #999; }
        .empty-cell { visibility: hidden; pointer-events: none; }

        /* Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(2px);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 2000;
        }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: white; padding: 25px; border-radius: 16px; width: 90%; max-width: 320px;
            text-align: center; position: relative; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 1.8rem; cursor: pointer; color: #aaa; }
        
        /* ç­†é †å®¹å™¨ */
        .stroke-container {
            width: 150px; height: 150px; background: #fff; border: 2px dashed #eee;
            border-radius: 8px; margin: 15px auto; position: relative; display: flex; align-items: center; justify-content: center;
        }
        .stroke-img { max-width: 100%; max-height: 100%; object-fit: contain; z-index: 2; display: none; }
        .loader { border: 3px solid #f3f3f3; border-top: 3px solid var(--primary-kana); border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; position: absolute;}
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* éŒ¯èª¤è¨Šæ¯ï¼šç¢ºä¿é è¨­éš±è— */
        #img-error { display: none; font-size: 0.8rem; color: #999; }

        .play-btn-kana {
            background: var(--primary-kana); color: white; border: none; padding: 10px 30px;
            border-radius: 25px; font-size: 1rem; cursor: pointer; display: inline-flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 10px rgba(255, 126, 179, 0.3); margin-top: 10px;
        }
        .play-btn-kana:hover { opacity: 0.9; }
        .mnemonic { margin-top: 15px; font-size: 0.9rem; color: #555; background: #fff5f8; padding: 10px; border-radius: 6px; text-align: left; border-left: 3px solid var(--primary-kana); }

        /* =========================================
           5. View B: å¥å­è§£æ
           ========================================= */
        .sentence-input-area { width: 100%; height: 100px; font-size: 16px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; margin-bottom: 15px; resize: vertical; }
        .btn-toolbar { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
        .action-btn {
            padding: 8px 16px; font-size: 14px; cursor: pointer; color: white; border: none; border-radius: 5px; 
            display: flex; align-items: center; gap: 6px; transition: opacity 0.2s;
        }
        .action-btn:hover { opacity: 0.9; }
        .action-btn:disabled { background-color: #ccc !important; cursor: not-allowed; }
        .btn-blue { background-color: #2196F3; } 
        .btn-green { background-color: #4CAF50; } 
        .btn-orange { background-color: #ff9800; } 
        .btn-red { background-color: #f44336; }

        #sentence-result { display: flex; flex-wrap: wrap; align-items: flex-end; row-gap: 24px; min-height: 100px;}
        .token { 
            font-size: 24px; color: #333; border-bottom: 2px solid #ddd; margin-right: 12px; padding: 2px 4px; 
            border-radius: 4px; cursor: pointer; position: relative; transition: all 0.2s; 
        }
        .token:hover { background-color: #e3f2fd; border-bottom-color: #2196F3; }
        .token.speaking { background-color: #E91E63 !important; color: white !important; border-bottom-color: #880E4F !important; transform: scale(1.1); z-index: 5; }
        .token.speaking rt { color: white; opacity: 1; }
        .speaker-icon { 
            display: none; position: absolute; top: -20px; right: -5px; font-size: 12px; 
            background-color: white; color: #333; border: 1px solid #ccc; border-radius: 50%; 
            width: 20px; height: 20px; text-align: center; line-height: 20px; z-index: 10; 
        }
        .token:hover .speaker-icon { display: block; }
        .token[data-pos="è¨˜å·"] { border-bottom: none; cursor: default; }
        .token[data-pos="è¨˜å·"]:hover { background: none; }
        .token[data-pos="è¨˜å·"] .speaker-icon { display: none !important; }
        
        rt { font-size: 12px; color: #d32f2f; opacity: 0; transition: opacity 0.3s; user-select: none; }
        .token:hover rt, .token.active rt { opacity: 1; }
        
        .sys-msg { font-size: 13px; color: #666; margin-top: 5px; font-style: italic;}

        @media (max-width: 600px) {
            .header-top { flex-direction: column; gap: 10px; align-items: flex-start; }
            .global-controls { width: 100%; justify-content: space-between; }
        }
    </style>
</head>
<body>

    <header class="app-header">
        <div class="header-top">
            <div class="app-title">ğŸ‡¯ğŸ‡µ æ—¥èªå­¸ç¿’åŠ©æ‰‹</div>
            
            <div class="global-controls">
                <div class="status-pill" onclick="AudioManager.toggleEngineMode()" title="é»æ“Šåˆ‡æ›æœ¬åœ°/é ç«¯ç™¼éŸ³">
                    <span id="global-mode-icon" class="status-icon">ğŸ’»</span>
                    
                    <span id="global-mode-text" class="status-text">åµæ¸¬ä¸­...</span>
                    
                    <div id="global-status-indicator" class="status-indicator"></div>
                </div>
                
                <div class="speed-control">
                    <span>ğŸ¢</span>
                    <input type="range" id="global-speed" min="0.5" max="2.0" step="0.1" value="1.0" oninput="document.getElementById('spd-val').innerText = this.value + 'x'">
                    <span style="font-size:12px; width:25px;" id="spd-val">1.0x</span>
                </div>
            </div>
        </div>

        <nav class="nav-tabs">
            <button class="tab-btn active" data-target="view-kana" onclick="switchTab('view-kana')">50éŸ³ç·´ç¿’</button>
            <button class="tab-btn" data-target="view-sentence" onclick="switchTab('view-sentence')">å¥å­è§£æ</button>
        </nav>
    </header>

    <main>
        <section id="view-kana" class="view-section active">
            <div class="kana-controls">
                <button class="kana-toggle-btn active" id="btn-mode-hira" onclick="KanaApp.setMode('hira')">å¹³å‡å</button>
                <button class="kana-toggle-btn" id="btn-mode-kata" onclick="KanaApp.setMode('kata')">ç‰‡å‡å</button>
            </div>
            
            <div class="grid-container" id="kana-grid"></div>
            
            <div class="modal-overlay" id="kana-modal" onclick="KanaApp.closeModal(event)">
                <div class="modal-content" onclick="event.stopPropagation()">
                    <span class="close-btn" onclick="KanaApp.closeModal()">&times;</span>
                    
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 3.5rem; color: var(--primary-kana); line-height: 1.2;" id="m-char"></div>
                        <div style="font-size: 1.2rem; font-weight: bold; color: #333;" id="m-romaji"></div>
                    </div>
                    
                    <div class="stroke-container">
                        <div class="loader" id="img-loader"></div>
                        <img id="stroke-img" class="stroke-img" alt="ç­†é †" onload="KanaApp.onImgLoad()" onerror="KanaApp.onImgError()">
                        <div id="img-error">ç„¡å½±åƒ</div>
                    </div>

                    <button class="play-btn-kana" onclick="KanaApp.playCurrentChar()">
                        ğŸ”Š è½ç™¼éŸ³
                    </button>

                    <div class="mnemonic" id="m-note"></div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 30px; font-size: 12px; color: #ccc;">å½±åƒä¾†æº: Wikimedia Commons</div>
        </section>

        <section id="view-sentence" class="view-section">
            <textarea id="input-text" class="sentence-input-area" placeholder="è«‹è¼¸å…¥æ—¥æ–‡å¥å­...">ä»Šæ—¥ã®å¤©æ°—ã¯ã¨ã¦ã‚‚ã„ã„ã§ã™ã­ã€‚</textarea>
            
            <div class="btn-toolbar">
                <button onclick="SentenceApp.tokenize()" class="action-btn btn-blue" id="btn-parse" disabled><span>ğŸ”</span> è§£æ</button>
                <button onclick="SentenceApp.playFull()" class="action-btn btn-green"><span>ğŸ”Š</span> æ•´å¥</button>
                <button onclick="SentenceApp.playSeq()" class="action-btn btn-orange" id="btn-seq" disabled><span>â–¶ï¸</span> é€è©</button>
                <button onclick="AudioManager.stopAll()" class="action-btn btn-red" id="btn-stop" disabled><span>â¹</span> åœæ­¢</button>
            </div>

            <div id="dic-status" class="sys-msg">æ­£åœ¨æº–å‚™å­—å…¸...</div>
            <div id="sentence-result"></div>
        </section>
    </main>

    <audio id="tts-player"></audio>
    <script src="https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/build/kuromoji.js"></script>

    <script>
        /**
         * =========================================================================
         * 1. AudioManager (æ ¸å¿ƒæœ—è®€æœå‹™)
         * =========================================================================
         */
        const AudioManager = {
            // æŒ‡å‘ä½¿ç”¨è€…æœ¬æ©Ÿçš„ Proxy
            PROXY_URL: "http://localhost:3000/tts",
			PROXY_CHECK_URL: "http://localhost:3000/ready",
            
            isProxyAvailable: false,
            // é è¨­å…ˆè¨­ç‚º falseï¼Œç­‰å¾…åµæ¸¬çµæœæ±ºå®šï¼Œé¿å… UI äº‚è·³
            isRemoteMode: false,
            localVoice: null,
            audioPlayer: document.getElementById('tts-player'),
            currentPlayId: 0,
            
            // ğŸ”¥ æ–°å¢ï¼šèªéŸ³åµæ¸¬çš„é€¾æ™‚é–å®šï¼Œé¿å…é‡è¤‡åˆ‡æ›
            voiceCheckTimeout: null,

            ui: {
                indicator: document.getElementById('global-status-indicator'),
                icon: document.getElementById('global-mode-icon'),
                text: document.getElementById('global-mode-text'),
                speed: document.getElementById('global-speed'),
                stopBtn: document.getElementById('btn-stop')
            },

            cache: {
                dbName: "JP_TTS_Cache", storeName: "audio_files", dbVersion: 1, maxSize: 200,
                async open() {
                    return new Promise((resolve, reject) => {
                        const r = indexedDB.open(this.dbName, this.dbVersion);
                        r.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if(!db.objectStoreNames.contains(this.storeName)) {
                                db.createObjectStore(this.storeName, { keyPath: "text" }).createIndex("timestamp", "timestamp");
                            }
                        };
                        r.onsuccess = (e) => resolve(e.target.result);
                        r.onerror = (e) => reject(e);
                    });
                },
                async get(text) {
                    try {
                        const db = await this.open();
                        return new Promise(r => {
                            const req = db.transaction(this.storeName, "readwrite").objectStore(this.storeName).get(text);
                            req.onsuccess = () => {
                                if(req.result) {
                                    req.result.timestamp = Date.now();
                                    db.transaction(this.storeName, "readwrite").objectStore(this.storeName).put(req.result);
                                    r(req.result.blob);
                                } else r(null);
                            };
                            req.onerror = () => r(null);
                        });
                    } catch { return null; }
                },
                async put(text, blob) {
                    try {
                        const db = await this.open();
                        const store = db.transaction(this.storeName, "readwrite").objectStore(this.storeName);
                        store.put({ text, blob, timestamp: Date.now() });
                    } catch {}
                }
            },

            init() {
                // 1. åµæ¸¬ Proxy (å»¶é²åŸ·è¡Œ)
                setTimeout(() => this.checkProxy(), 800);

                // 2. åµæ¸¬æœ¬åœ°èªéŸ³ (Web Speech API)
                // è¨»å†Šäº‹ä»¶ç›£è½å™¨ï¼šç•¶ Android èªéŸ³åŒ…è¼‰å…¥å®Œæˆæ™‚è§¸ç™¼
                if (window.speechSynthesis.onvoiceschanged !== undefined) {
                    window.speechSynthesis.onvoiceschanged = () => this.detectLocalVoice(false);
                }
                
                // ç«‹å³å˜—è©¦ä¸€æ¬¡ (é‡å° PC)
                this.detectLocalVoice(false);

                // ğŸ”¥ 3. è¨­å®šã€Œæœ€å¾Œé€šç‰’ã€é€¾æ™‚æ©Ÿåˆ¶ (é‡å° Android)
                // å¦‚æœ 2.5 ç§’å¾Œ onvoiceschanged é‚„æ²’è§¸ç™¼ï¼Œæˆ–è€…æ¸…å–®é‚„æ˜¯ç©ºçš„ï¼Œå°±å¼·åˆ¶åˆ¤å®šã€‚
                this.voiceCheckTimeout = setTimeout(() => {
                    this.detectLocalVoice(true);
                }, 2500);
            },

            async checkProxy() {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1500);
                    const res = await fetch(`${this.PROXY_CHECK_URL}`, { method: 'GET', signal: controller.signal });
                    clearTimeout(timeoutId);
                    
                    if (res.ok) {
                        this.isProxyAvailable = true;
                    } else {
                        this.isProxyAvailable = false;
                    }
                } catch (e) {
                    this.isProxyAvailable = false; 
                }
                this.updateUI();
            },

            // ğŸ”¥ ä¿®æ­£å¾Œçš„èªéŸ³åµæ¸¬é‚è¼¯
            // forceDecision: æ˜¯å¦ç‚ºé€¾æ™‚å¼·åˆ¶åˆ¤å®š
            detectLocalVoice(forceDecision) {
                const voices = window.speechSynthesis.getVoices();
                
                // æƒ…æ³ A: ç€è¦½å™¨é‚„åœ¨è¼‰å…¥èªéŸ³ (é™£åˆ—ç‚ºç©º)ï¼Œä¸”é‚„æ²’åˆ°é€¾æ™‚æ™‚é–“ -> ç¹¼çºŒç­‰å¾…ï¼Œä¸åˆ‡æ›
                if (voices.length === 0 && !forceDecision) {
                    // ä¿æŒç¾ç‹€ (UI é¡¯ç¤ºåµæ¸¬ä¸­...)
                    return;
                }

                // æƒ…æ³ B: èªéŸ³æ¸…å–®å·²è¼‰å…¥ OR å·²ç¶“é€¾æ™‚ (å¿…é ˆåšæ±ºå®šäº†)
                
                // å°‹æ‰¾æ—¥æ–‡èªéŸ³
                const jaVoice = voices.find(v => v.lang === 'ja-JP') || voices.find(v => v.lang.startsWith('ja'));
                
                if (jaVoice) {
                    // âœ… æ‰¾åˆ°äº†ï¼ä½¿ç”¨æœ¬åœ°èªéŸ³
                    this.localVoice = jaVoice;
                    this.isRemoteMode = false;
                    
                    // å¦‚æœé€™æ˜¯åœ¨é€¾æ™‚ä¹‹å‰ç™¼ç”Ÿçš„ï¼Œè¨˜å¾—æ¸…é™¤é€¾æ™‚è¨ˆæ™‚å™¨ï¼Œé¿å…ç¨å¾Œé‡è¤‡åŸ·è¡Œ
                    if (this.voiceCheckTimeout) {
                        clearTimeout(this.voiceCheckTimeout);
                        this.voiceCheckTimeout = null;
                    }
                } else {
                    // âŒ æ‰¾ä¸åˆ° (æ˜¯çœŸçš„æ²’å®‰è£ï¼Œæˆ–æ˜¯é€¾æ™‚äº†é‚„æ²’è¼‰å…¥) -> åˆ‡æ›é ç«¯
                    this.localVoice = null;
                    this.isRemoteMode = true;
                }

                this.updateUI();
            },

            toggleEngineMode() {
                this.isRemoteMode = !this.isRemoteMode;
                this.updateUI();
            },

            updateUI() {
                this.ui.indicator.className = 'status-indicator'; 
                
                if (this.isRemoteMode) {
                    this.ui.icon.textContent = 'â˜ï¸';
                    this.ui.indicator.classList.add('visible'); 
                    
                    if (this.isProxyAvailable) {
                        this.ui.text.innerHTML = `é ç«¯ (Google)`;
                    } else {
                        this.ui.text.innerHTML = `é ç«¯ (Google) <small style="opacity:0.7">ç„¡å¿«å–</small>`;
                    }
                } else {
                    this.ui.icon.textContent = 'ğŸ’»';
                    this.ui.indicator.classList.remove('visible'); 
                    if (this.localVoice) {
                        this.ui.text.innerHTML = `æœ¬åœ° (${this.localVoice.name.substring(0, 10)}...)`;
                    } else {
                        this.ui.text.innerHTML = `æœ¬åœ° (é è¨­)`;
                    }
                }
            },

            setLight(color) { 
                if (!this.isRemoteMode) return;
                this.ui.indicator.className = 'status-indicator visible';
                if(color === 'green') this.ui.indicator.classList.add('status-green');
                else if(color === 'orange') this.ui.indicator.classList.add('status-orange');
            },

            stopAll() {
                this.currentPlayId++; 
                if(this.ui.stopBtn) this.ui.stopBtn.disabled = true;
                
                this.audioPlayer.oncanplay = null;
                this.audioPlayer.onended = null;
                this.audioPlayer.onerror = null;

                this.audioPlayer.pause();
                try { this.audioPlayer.currentTime = 0; } catch(e) {}
                
                window.speechSynthesis.cancel();
                this.setLight('gray');
                
                if (typeof SentenceApp !== 'undefined') {
                    SentenceApp.stopSequenceUI();
                }
            },

            play(text, onComplete) {
                const myRequestId = ++this.currentPlayId;
                const speed = parseFloat(this.ui.speed.value);
                
                if (!this.isRemoteMode) {
                    window.speechSynthesis.cancel();
                    const utter = new SpeechSynthesisUtterance(text);
                    utter.lang = 'ja-JP';
                    if (this.localVoice) utter.voice = this.localVoice;
                    utter.rate = speed;
                    utter.onend = () => { 
                        if(this.currentPlayId === myRequestId && onComplete) onComplete(); 
                    };
                    utter.onerror = (e) => { 
                        console.error(e); 
                        if(this.currentPlayId === myRequestId && onComplete) onComplete(); 
                    };
                    window.speechSynthesis.speak(utter);
                } else {
                    this.playRemote(text, speed, onComplete, myRequestId);
                }
            },

            async playRemote(text, speed, onComplete, requestId) {
                if (requestId !== this.currentPlayId) return;

                const doPlay = (url) => {
                    if (requestId !== this.currentPlayId) return;
                    this.audioPlayer.src = url;

                    this.audioPlayer.oncanplay = () => {
                        if (requestId !== this.currentPlayId) return;
                        this.audioPlayer.playbackRate = speed;
                        this.audioPlayer.play().catch(() => {
                            if (requestId === this.currentPlayId) {
                                this.setLight('gray'); if(onComplete) onComplete();
                            }
                        });
                    };
                    this.audioPlayer.onended = () => {
                        if (requestId !== this.currentPlayId) return;
                        this.setLight('gray'); if(onComplete) onComplete();
                    };
                    this.audioPlayer.onerror = () => {
                        if (requestId !== this.currentPlayId) return;
                        this.setLight('gray'); if(onComplete) onComplete();
                    };
                };

                const cachedBlob = await this.cache.get(text);
                if (requestId !== this.currentPlayId) return;

                if (cachedBlob) {
                    this.setLight('green');
                    doPlay(URL.createObjectURL(cachedBlob));
                    return;
                }

                this.setLight('orange');
                if (this.isProxyAvailable) {
                    try {
                        const res = await fetch(`${this.PROXY_URL}?q=${encodeURIComponent(text)}`);
                        if (requestId !== this.currentPlayId) return;
                        if (!res.ok) throw new Error();
                        const blob = await res.blob();
                        this.cache.put(text, blob);
                        doPlay(URL.createObjectURL(blob));
                        return;
                    } catch (e) {}
                }

                if (requestId !== this.currentPlayId) return;
                const directUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=ja&client=tw-ob&q=${encodeURIComponent(text)}&t=${Date.now()}`;
                doPlay(directUrl);
            }
        };

        /**
         * =========================================================================
         * 2. KanaApp (50éŸ³é‚è¼¯)
         * =========================================================================
         */
        const KanaApp = {
            data: [
                { r: 'a', h: 'ã‚', k: 'ã‚¢', note: 'ã€Œã‚ã€é•·å¾—åƒã€Œå®‰ã€å…¨çš„å®‰ã€‚' }, { r: 'i', h: 'ã„', k: 'ã‚¤', note: 'ã€Œã„ã€åƒæ¼¢å­—ã€Œä»¥ã€çš„å·¦é‚Šã€‚' }, { r: 'u', h: 'ã†', k: 'ã‚¦', note: 'ã€Œã†ã€ä¸Šé¢ä¸€é»ï¼Œåƒæ³¨éŸ³ã€Œã„…ã€ä¸Šé¢åŠ ä¸€é»ã€‚' }, { r: 'e', h: 'ãˆ', k: 'ã‚¨', note: 'ã€Œãˆã€åƒæ¼¢å­—ã€Œå…ƒã€çš„è‰å¯«ã€‚' }, { r: 'o', h: 'ãŠ', k: 'ã‚ª', note: 'ã€ŒãŠã€åƒåœ¨æ‰“é«˜çˆ¾å¤«çƒçš„å§¿å‹¢ã€‚' },
                { r: 'ka', h: 'ã‹', k: 'ã‚«', note: 'ã€Œã‹ã€å°±æ˜¯ã€ŒåŠ ã€æ²¹çš„åŠ ã€‚' }, { r: 'ki', h: 'ã', k: 'ã‚­', note: 'ã€Œkiã€åƒå‰ä»–çš„ç´é ¸ã€‚' }, { r: 'ku', h: 'ã', k: 'ã‚¯', note: 'ã€Œkuã€åƒé³¥çš„å˜´å·´ (Cuckoo)ã€‚' }, { r: 'ke', h: 'ã‘', k: 'ã‚±', note: 'ã€Œkeã€åƒæ¼¢å­—ã€Œè¨ˆã€çš„å·¦é‚Šã€‚' }, { r: 'ko', h: 'ã“', k: 'ã‚³', note: 'ã€Œã“ã€æ˜¯å…©æ¢ç·šï¼Œåƒã€Œå·±ã€ã€‚' },
                { r: 'sa', h: 'ã•', k: 'ã‚µ', note: 'ã€Œã•ã€åƒæ®ºæ°£çš„ã€Œæ®ºã€è‰å¯«ã€‚' }, { r: 'shi', h: 'ã—', k: 'ã‚·', note: 'ã€Œã—ã€åƒå¸ç®¡çš„å½¢ç‹€ã€‚' }, { r: 'su', h: 'ã™', k: 'ã‚¹', note: 'ã€Œsuã€è£¡é¢æœ‰å€‹åœˆåœˆï¼Œåƒç›ªé¦éŸ†ã€‚' }, { r: 'se', h: 'ã›', k: 'ã‚»', note: 'ã€Œseã€åƒä¸–ç•Œçš„ã€Œä¸–ã€ã€‚' }, { r: 'so', h: 'ã', k: 'ã‚½', note: 'ã€Œsoã€åƒZä¸Šé¢åŠ ä¸€é»ã€‚' },
                { r: 'ta', h: 'ãŸ', k: 'ã‚¿', note: 'ã€Œtaã€åƒæ¼¢å­—ã€Œå¤ªã€ã€‚' }, { r: 'chi', h: 'ã¡', k: 'ãƒ', note: 'ã€Œchiã€åƒæ•¸å­—ã€Œ5ã€ï¼Œä¹Ÿåƒä¸ƒã€‚' }, { r: 'tsu', h: 'ã¤', k: 'ãƒ„', note: 'ã€Œtsuã€åƒåˆºèŸçš„åˆºï¼Œæˆ–æ˜¯æµ·å˜¯ (Tsunami)ã€‚' }, { r: 'te', h: 'ã¦', k: 'ãƒ†', note: 'ã€Œteã€åƒå±•é–‹çš„æ‰‹ã€‚' }, { r: 'to', h: 'ã¨', k: 'ãƒˆ', note: 'ã€Œtoã€åƒå…”å­çš„è€³æœµã€‚' },
                { r: 'na', h: 'ãª', k: 'ãƒŠ', note: 'ã€Œnaã€åƒã€Œå¥ˆã€è‰¯çš„å¥ˆã€‚' }, { r: 'ni', h: 'ã«', k: 'ãƒ‹', note: 'ã€Œniã€å°±æ˜¯æ¼¢å­—ã€ŒäºŒã€åŠ ä¸Šä¸€è±ã€‚' }, { r: 'nu', h: 'ã¬', k: 'ãƒŒ', note: 'ã€Œnuã€åƒå¥´éš¸çš„ã€Œå¥´ã€ã€‚' }, { r: 'ne', h: 'ã­', k: 'ãƒ', note: 'ã€Œneã€çµå°¾æœ‰å€‹åœˆï¼Œåƒè²“çš„å°¾å·´ (Neko)ã€‚' }, { r: 'no', h: 'ã®', k: 'ãƒ', note: 'ã€Œnoã€å°±åƒç¦æ­¢æ¨™èªŒã€‚' },
                { r: 'ha', h: 'ã¯', k: 'ãƒ', note: 'ã€Œhaã€åƒå“ˆæ°£çš„å‹•ä½œã€‚' }, { r: 'hi', h: 'ã²', k: 'ãƒ’', note: 'ã€Œhiã€åƒä¸€å€‹äººåœ¨ç¬‘å˜»å˜»çš„å˜´å‹ã€‚' }, { r: 'fu', h: 'ãµ', k: 'ãƒ•', note: 'ã€Œfuã€åƒå¯Œå£«å±±ã€‚' }, { r: 'he', h: 'ã¸', k: 'ãƒ˜', note: 'ã€Œheã€å°±æ˜¯æŒ‡è‘—é æ–¹ (Hey!)ã€‚' }, { r: 'ho', h: 'ã»', k: 'ãƒ›', note: 'ã€Œhoã€åƒä¿è­·çš„ã€Œä¿ã€ã€‚' },
                { r: 'ma', h: 'ã¾', k: 'ãƒ', note: 'ã€Œmaã€åƒåª½åª½æŠ±å°å­©ã€‚' }, { r: 'mi', h: 'ã¿', k: 'ãƒŸ', note: 'ã€Œmiã€åƒç¾å¦™çš„ã€Œç¾ã€ä¸‹é¢ã€‚' }, { r: 'mu', h: 'ã‚€', k: 'ãƒ ', note: 'ã€Œmuã€åƒç‰›åœ¨å« Moo~ã€‚' }, { r: 'me', h: 'ã‚', k: 'ãƒ¡', note: 'ã€Œmeã€åƒéºµæ¢çš„ã€Œéºµã€å¥³å­—é‚Šã€‚' }, { r: 'mo', h: 'ã‚‚', k: 'ãƒ¢', note: 'ã€Œmoã€åƒæ¯›æ¯›èŸ²çš„ã€Œæ¯›ã€ã€‚' },
                { r: 'ya', h: 'ã‚„', k: 'ãƒ¤', note: 'ã€Œyaã€åƒé´¨å­çš„é´¨ã€‚' }, { empty: true }, { r: 'yu', h: 'ã‚†', k: 'ãƒ¦', note: 'ã€Œyuã€åƒç”±ä¾†çš„ã€Œç”±ã€è‰å¯«ã€‚' }, { empty: true }, { r: 'yo', h: 'ã‚ˆ', k: 'ãƒ¨', note: 'ã€Œyoã€åƒç©æºœæºœçƒ Yo-Yoã€‚' },
                { r: 'ra', h: 'ã‚‰', k: 'ãƒ©', note: 'ã€Œraã€åƒé¦¬æ¡¶è“‹ (Lavatory)ã€‚' }, { r: 'ri', h: 'ã‚Š', k: 'ãƒª', note: 'ã€Œriã€åƒåˆ©ç›Šçš„ã€Œåˆ©ã€å³é‚Šã€‚' }, { r: 'ru', h: 'ã‚‹', k: 'ãƒ«', note: 'ã€Œruã€å°¾å·´æœ‰åœˆåœˆ (Loop)ã€‚' }, { r: 're', h: 'ã‚Œ', k: 'ãƒ¬', note: 'ã€Œreã€åƒç¦®è²Œçš„ã€Œç¦®ã€å³é‚Šã€‚' }, { r: 'ro', h: 'ã‚', k: 'ãƒ­', note: 'ã€Œroã€åƒã€Œã‚‹ã€ä½†æ²’æœ‰åœˆåœˆã€‚' },
                { r: 'wa', h: 'ã‚', k: 'ãƒ¯', note: 'ã€Œwaã€åƒå“‡å“‡å¤§å“­çš„æ¨£å­ã€‚' }, { empty: true }, { empty: true }, { empty: true }, { r: 'wo', h: 'ã‚’', k: 'ãƒ²', note: 'ã€Œwoã€è®€éŸ³åŒ oï¼Œé€šå¸¸ç•¶åŠ©è©ã€‚' },
                { r: 'n', h: 'ã‚“', k: 'ãƒ³', note: 'ã€Œnã€åƒè‹±æ–‡æ‰‹å¯«çš„ nã€‚' }, { empty: true }, { empty: true }, { empty: true }, { empty: true }
            ],
            currentMode: 'hira',
            currentItem: null,

            init() {
                this.renderGrid();
            },

            setMode(mode) {
                this.currentMode = mode;
                document.getElementById('btn-mode-hira').classList.toggle('active', mode === 'hira');
                document.getElementById('btn-mode-kata').classList.toggle('active', mode === 'kata');
                this.renderGrid();
            },

            renderGrid() {
                const container = document.getElementById('kana-grid');
                container.innerHTML = '';
                this.data.forEach(item => {
                    const card = document.createElement('div');
                    if (item.empty) {
                        card.className = 'char-card empty-cell';
                    } else {
                        card.className = 'char-card';
                        card.innerHTML = `<div class="char-main">${this.currentMode === 'hira' ? item.h : item.k}</div><div class="char-sub">${item.r}</div>`;
                        card.onclick = () => this.openModal(item);
                    }
                    container.appendChild(card);
                });
            },

            openModal(item) {
                this.currentItem = item;
                const modal = document.getElementById('kana-modal');
                const mainChar = this.currentMode === 'hira' ? item.h : item.k;
                document.getElementById('m-char').textContent = mainChar;
                document.getElementById('m-romaji').textContent = item.r;
                document.getElementById('m-note').innerHTML = `<b>ğŸ’¡ è¨˜æ†¶ï¼š</b>${item.note}`;
                
                const img = document.getElementById('stroke-img');
                const loader = document.getElementById('img-loader');
                const err = document.getElementById('img-error');
                
                img.style.display = 'none'; 
                loader.style.display = 'block'; 
                err.style.display = 'none';
                img.removeAttribute('src'); 
                
                this.fetchWikiImage(mainChar, this.currentMode).then(url => { img.src = url; })
                    .catch((e) => { console.error(e); this.onImgError(); });
                
                modal.classList.add('open');
            },

            closeModal(e) {
                if(e && e.target.closest('.modal-content')) return;
                document.getElementById('kana-modal').classList.remove('open');
                AudioManager.stopAll();
            },

            playCurrentChar() {
                if(!this.currentItem) return;
                const text = this.currentMode === 'hira' ? this.currentItem.h : this.currentItem.k;
                AudioManager.play(text);
            },

            async fetchWikiImage(char, mode) {
                const prefix = mode === 'hira' ? 'Hiragana' : 'Katakana';
                const filename = `File:${prefix}_${char}_stroke_order_animation.gif`;
                const params = new URLSearchParams({
                    action: 'query', titles: filename, prop: 'imageinfo', iiprop: 'url', format: 'json', origin: '*'
                });
                const res = await fetch(`https://commons.wikimedia.org/w/api.php?${params.toString()}`);
                const data = await res.json();
                const pages = data.query.pages;
                const pageId = Object.keys(pages)[0];
                if(pageId === "-1") throw new Error("Image not found");
                return pages[pageId].imageinfo[0].url;
            },

            onImgLoad() {
                document.getElementById('img-loader').style.display = 'none';
                document.getElementById('stroke-img').style.display = 'block';
            },
            onImgError() {
                const img = document.getElementById('stroke-img');
                if (!img.getAttribute('src')) return;
                document.getElementById('img-loader').style.display = 'none';
                document.getElementById('stroke-img').style.display = 'none';
                document.getElementById('img-error').style.display = 'block';
            }
        };

        /**
         * =========================================================================
         * 3. SentenceApp (å¥å­è§£æé‚è¼¯)
         * =========================================================================
         */
        const SentenceApp = {
            tokenizer: null,
            tokens: [],
            isSequencing: false,
            seqIndex: 0,
            currentSeqId: 0,
            
            // å­—å…¸ä½ç½®
            CDN_DIC_URL: "https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/dict/",
            LOCAL_DIC_URL: "dict/",

            init() {
                this.initSmartDictionary();
            },

            async initSmartDictionary() {
                const statusDiv = document.getElementById('dic-status');
                
                const protocol = window.location.protocol;
                const isLocalFileMode = (protocol === 'file:');
                
                let targetPath = "";
                let sourceName = "";

                if (isLocalFileMode) {
                    targetPath = this.CDN_DIC_URL;
                    sourceName = "CDN";
                } else {
                    targetPath = this.LOCAL_DIC_URL;
                    sourceName = "Server";
                }

                statusDiv.innerHTML = `æ­£åœ¨æ¸¬è©¦å­—å…¸: ${sourceName}...`;

                const isPathOk = await this.checkPathAccessibility(targetPath);
                
                if (isPathOk) {
                    this.loadKuromoji(targetPath, sourceName);
                } else {
                    console.warn(`Dictionary check failed for ${targetPath}`);
                    
                    if (!isLocalFileMode) {
                        statusDiv.innerHTML = `<span style="color: #d32f2f;">âŒ Server å­—å…¸æª”éºå¤±<br><small>Server æ¨¡å¼ä¸‹ä¸ä½¿ç”¨ CDN</small></span>`;
                    } else {
                        statusDiv.innerHTML = `<span style="color: #d32f2f;">âŒ ç„¡æ³•é€£ç·šè‡³ CDN å­—å…¸</span>`;
                    }
                }
            },

            async checkPathAccessibility(baseUrl) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); 
                try {
                    const response = await fetch(baseUrl + "base.dat.gz", { method: 'HEAD', signal: controller.signal });
                    clearTimeout(timeoutId);
                    return response.ok;
                } catch (error) {
                    clearTimeout(timeoutId);
                    return false;
                }
            },

            loadKuromoji(path, sourceName) {
                const statusDiv = document.getElementById('dic-status');
                statusDiv.innerHTML = `æ­£åœ¨ä¸‹è¼‰å­—å…¸ (${sourceName})...`;
                
                kuromoji.builder({ dicPath: path }).build((err, _tokenizer) => {
                    if (err) {
                        console.error(err);
                        statusDiv.innerHTML = `<span style="color:red">å­—å…¸è¼‰å…¥å¤±æ•—</span>`;
                    } else {
                        this.tokenizer = _tokenizer;
                        statusDiv.innerHTML = `<span style="color:green">âœ… å­—å…¸å°±ç·’ (${sourceName})</span>`;
                        document.getElementById('btn-parse').disabled = false;
                        document.getElementById('btn-seq').disabled = false;
                    }
                });
            },

            tokenize() {
                if (!this.tokenizer) return;
                const text = document.getElementById('input-text').value;
                const resultDiv = document.getElementById('sentence-result');
                resultDiv.innerHTML = '';
                
                const rawTokens = this.tokenizer.tokenize(text);
                
                rawTokens.forEach(token => {
                    const surface = token.surface_form;
                    const readingKata = token.reading || surface;
                    const readingHira = readingKata.replace(/[\u30a1-\u30f6]/g, m => String.fromCharCode(m.charCodeAt(0) - 0x60));
                    const needFuri = (surface !== readingHira && surface !== readingKata);
                    const pos = token.pos;

                    const span = document.createElement('span');
                    span.className = 'token';
                    span.dataset.text = surface; 
                    span.dataset.pos = pos;

                    let html = needFuri ? `<ruby>${surface}<rt>${readingHira}</rt></ruby>` : surface;
                    if(pos !== "è¨˜å·" && surface.trim()) {
                        html += `<span class="speaker-icon" onclick="event.stopPropagation(); AudioManager.play('${surface}')">ğŸ”Š</span>`;
                        span.onclick = function() { this.classList.toggle('active'); };
                    }
                    span.innerHTML = html;
                    resultDiv.appendChild(span);
                });
                this.tokens = document.querySelectorAll('.token');
            },

            playFull() {
                AudioManager.stopAll();
                const text = document.getElementById('input-text').value;
                if(!text) return;
                document.getElementById('btn-stop').disabled = false;
                AudioManager.play(text, () => { document.getElementById('btn-stop').disabled = true; });
            },

            playSeq() {
                AudioManager.stopAll();
                this.currentSeqId++; 
                if(this.tokens.length === 0) {
                    this.tokenize();
                    if(this.tokens.length === 0) return;
                }
                this.isSequencing = true;
                this.seqIndex = 0;
                document.getElementById('btn-stop').disabled = false;
                this.playNextToken(this.currentSeqId);
            },

            playNextToken(seqId) {
                if (seqId !== this.currentSeqId) return;

                if(!this.isSequencing || this.seqIndex >= this.tokens.length) {
                    this.stopSequenceUI();
                    return;
                }
                const el = this.tokens[this.seqIndex];
                const text = el.dataset.text;
                const pos = el.dataset.pos;

                if (pos === "è¨˜å·" || !text.trim()) {
                    this.seqIndex++; 
                    setTimeout(() => this.playNextToken(seqId), 0); 
                    return;
                }

                el.classList.add('speaking');
                const delay = AudioManager.isRemoteMode ? 100 : 10;
                
                setTimeout(() => {
                    if(!this.isSequencing || seqId !== this.currentSeqId) {
                         el.classList.remove('speaking'); return;
                    }
                    AudioManager.play(text, () => {
                        if (seqId !== this.currentSeqId) {
                            el.classList.remove('speaking'); return;
                        }
                        el.classList.remove('speaking');
                        this.seqIndex++;
                        const spd = parseFloat(document.getElementById('global-speed').value);
                        const gap = AudioManager.isRemoteMode ? 200 : 50;
                        if(this.isSequencing) {
                            setTimeout(() => this.playNextToken(seqId), gap/spd);
                        }
                    });
                }, delay);
            },

            stopSequenceUI() {
                this.isSequencing = false;
                this.currentSeqId++; 
                document.querySelectorAll('.token.speaking').forEach(el => el.classList.remove('speaking'));
                document.getElementById('btn-stop').disabled = true;
            }
        };

        function switchTab(viewId) {
            AudioManager.stopAll();
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.target === viewId);
            });
            document.querySelectorAll('.view-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(viewId).classList.add('active');
        }

        AudioManager.init();
        KanaApp.init();
        SentenceApp.init(); 

    </script>
</body>
</html>
